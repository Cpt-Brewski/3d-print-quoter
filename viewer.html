<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;overflow:hidden}
    #c{width:100%;height:100%;display:block}
    #overlay{position:absolute;inset:12px auto auto 12px;background:rgba(0,0,0,.6);color:#fff;padding:6px 10px;border-radius:10px;font:12px system-ui}
  </style>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/loaders/STLLoader.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/loaders/3MFLoader.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/libs/fflate.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/utils/BufferGeometryUtils.js"></script>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="overlay">Drop file or wait…</div>
  <script>
    const canvas = document.getElementById('c');
    const overlay = document.getElementById('overlay');

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8fafc);

    const camera = new THREE.PerspectiveCamera(50, 2, 0.1, 1000);
    camera.position.set(120, 90, 140);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const light1 = new THREE.DirectionalLight(0xffffff, 1);
    light1.position.set(1, 1, 1);
    scene.add(light1);
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));

    const grid = new THREE.GridHelper(400, 40, 0xcccccc, 0xe5e7eb);
    grid.position.y = -0.01;
    scene.add(grid);

    let mesh = null;

    function fitCameraToObject(object) {
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z) || 1;

      const fitDist = maxDim / (2 * Math.tan((Math.PI * camera.fov) / 360));
      const dir = new THREE.Vector3(1, 0.8, 1).normalize();
      camera.position.copy(center).add(dir.multiplyScalar(fitDist * 1.4));

      camera.near = Math.max(maxDim / 100, 0.01);
      camera.far = Math.max(maxDim * 100, 1000);
      camera.updateProjectionMatrix();

      controls.target.copy(center);
      controls.update();
    }

    function computeVolumeAndArea(geometry) {
      const pos = geometry.getAttribute('position');
      const index = geometry.getIndex();
      let volume = 0, area = 0;

      const vA = new THREE.Vector3(), vB = new THREE.Vector3(), vC = new THREE.Vector3();
      const cb = new THREE.Vector3(), ab = new THREE.Vector3();

      if (index) {
        for (let i = 0; i < index.count; i += 3) {
          vA.fromBufferAttribute(pos, index.getX(i));
          vB.fromBufferAttribute(pos, index.getX(i + 1));
          vC.fromBufferAttribute(pos, index.getX(i + 2));
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          area += cb.cross(ab).length() * 0.5;
          volume += vA.dot(vB.clone().cross(vC)) / 6.0;
        }
      } else {
        // Non-indexed: positions are laid out as triplets of vertices (A,B,C)
        for (let i = 0; i < pos.count; i += 3) {
          vA.fromBufferAttribute(pos, i);
          vB.fromBufferAttribute(pos, i + 1);
          vC.fromBufferAttribute(pos, i + 2);
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          area += cb.cross(ab).length() * 0.5;
          volume += vA.dot(vB.clone().cross(vC)) / 6.0;
        }
      }
      return { volume: Math.abs(volume), area };
    }

    function clearMesh() {
      if (mesh) {
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
        mesh = null;
      }
    }

    function loadFromArrayBuffer(arrayBuffer, filename) {
      clearMesh();
      const ext = (filename.split('.').pop() || '').toLowerCase();

      let geometry;
      if (ext === 'stl') {
        geometry = new THREE.STLLoader().parse(arrayBuffer);
        // Ensure smooth shading for many STLs
        if (!geometry.attributes.normal) geometry.computeVertexNormals();
      } else if (ext === '3mf') {
        const model = new THREE.ThreeMFLoader().parse(arrayBuffer);
        const geoms = [];
        model.traverse(child => { if (child.isMesh && child.geometry) geoms.push(child.geometry.clone()); });
        if (!geoms.length) throw new Error('No mesh geometry found in 3MF');
        geometry = THREE.BufferGeometryUtils.mergeGeometries(geoms, false);
        if (!geometry.attributes.normal) geometry.computeVertexNormals();
      } else {
        throw new Error('Unsupported extension: ' + ext);
      }

      const mat = new THREE.MeshStandardMaterial({ color: 0x8da2fb, metalness: 0.05, roughness: 0.9 });
      mesh = new THREE.Mesh(geometry, mat);
      scene.add(mesh);

      fitCameraToObject(mesh);

      const box = new THREE.Box3().setFromObject(mesh);
      const size = box.getSize(new THREE.Vector3());
      const metrics = computeVolumeAndArea(mesh.geometry);

      parent.postMessage({
        type: 'metrics',
        bbox: { x: size.x, y: size.y, z: size.z },
        volume_mm3: metrics.volume,
        area_mm2: metrics.area,
        filename
      }, '*');

      overlay.textContent = filename + ' loaded';
    }

    window.addEventListener('message', (e) => {
      const msg = e.data || {};
      if (msg.type === 'loadModel' && msg.arrayBuffer && msg.filename) {
        overlay.textContent = 'Parsing ' + msg.filename + ' …';
        try {
          loadFromArrayBuffer(msg.arrayBuffer, msg.filename);
        } catch (err) {
          parent.postMessage({ type: 'error', message: err.message || String(err) }, '*');
          overlay.textContent = 'Error: ' + (err.message || err);
        }
      }
    });

    function resizeRendererToDisplaySize() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      if (canvas.width !== w || canvas.height !== h) {
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
    }

    function render() {
      resizeRendererToDisplaySize();
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    render();

    // Drag & drop support inside iframe (handy for testing viewer.html directly)
    document.addEventListener('dragover', (e) => { e.preventDefault(); overlay.textContent = 'Drop to view…'; });
    document.addEventListener('drop', async (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      if (file) {
        overlay.textContent = 'Loading ' + file.name + ' …';
        const buf = await file.arrayBuffer();
        loadFromArrayBuffer(buf, file.name);
      }
    });
  </script>
</body>
</html>
